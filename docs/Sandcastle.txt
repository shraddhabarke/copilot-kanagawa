Sandcastle

Generate documentation from annotated Sandpiper source code.


Table of Contents

- Goals
- Invocation
- Documentation and markup Documenting top-level declaration Documenting parts of a declaration Class methods, variables, and callbacks struct, enum, and union fields Template parameters and function arguments Documentation structure Module description Hyperlinking Markup Svgbob Anchors Collapsible Examples
- References

- Documenting top-level declaration
- Documenting parts of a declaration Class methods, variables, and callbacks struct, enum, and union fields Template parameters and function arguments
- Documentation structure Module description Hyperlinking
- Markup Svgbob Anchors Collapsible Examples

- Class methods, variables, and callbacks
- struct, enum, and union fields
- Template parameters and function arguments

- Module description
- Hyperlinking

- Svgbob
- Anchors
- Collapsible Examples


Goals ¶

Sandcastle is designed to fulfill several goals:

- Generate documentation from Sandpiper modules, extracting API documentation from exposed type aliases, functions, classes, etc. The generated documentation will encapsulate only the interface that is available to the module user.
- Keep the documentation as close as possible to the implementation of the API. Sandcastle allows the programmer to write documentation for any entity adjacent to the definition of the entity in the source code.
- Documentation annotations are non-intrusive and do not obfuscate the source code. Annotations should be lightweight and easy to read and write while also supporting basic markdown features.
- Recognize the language scopes and module system. Generated documentation should display information important to users.
- Navigation via hyperlinks. Documentation generated by Sandcastle makes abundant use of hyperlinks and anchors. Identifiers are linked and declarations are anchored including their respective components. Furthermore, user-written annotations may contain hyperlinks.
- Produce documentation in multiple formats. Sandcastle supports a markdown and html backend. Adding new backends is straightforward and flexible.


Invocation ¶

Sandcastle is invoked from the command line:

sandcastle [OPTIONS] [FILE]

Where each FILE is a filename containing a Sandpiper source module. Files can be absolute paths or relative paths to the current directory. Use the option -? or --help to see a list of all command line options.

The modules specified on the command line are processed together. When one module refers to an type declared in another module being processed, the documentation will link to that declaration. The modules should not be mutually recursive. Currently, links to entities that cannot be found will be dead links.

Sandcastle currently only supports generating Markdown and HTML documentation.


Documentation and markup ¶

Sandcastle recognizes special documentation annotations in the Sandpiper source file and transforms these into generated documentation. If there are no annotations, Sandcastle generates documentation that incorporates exposed type alias, enum, struct, function, and class declarations.

The annotation is a language comment and is parsed by the PipeDream compiler using the --parse-docs command-line switch.


Documenting top-level declaration ¶

The simplest documentation annotation is for a top-level declaration. Suppose the source file contains the following function:

template <typename T>
inline T xor(T a, T b)
{
    return a ^ b;
}

Then we can document it like this:

//| Return xor of inputs.
template <typename T>
inline T xor(T a, T b)
{
    return a ^ b;
}

The annotation begins with the //| syntax and applies to the following declaration in the source file. Additionally, Sandcastle supports writing documentation after the declaration by using //< .

template
  < typename T //< Type of number to square
  , typename R //< Return type of squared number
  >
inline R square
    ( T x //< Input number
    )
{
    return x * x;
}
//< Square a number

Annotations can span several lines and continue until the first non-comment line in the source file.

//| Adds two values of the input type.
// Returns the result as the output type, which might be larger.
// e.g. 3 fits in a uint2, but 3 + 3 does not.
template <typename R, typename T>
inline R add(T a, T b)
{
    return a + b;
}

The line comment style // requires a single space of margin after the comment prefix, | or / , and after each subsequent line.

Annotations can also utilize Sandpiper’s multi-line comment style. This style does not require a single space margin.

/*|
Adds two values of the input type.
Returns the result as the output type, which might be larger.
e.g. 3 fits in a uint2, but 3 + 3 does not.
*/
template <typename R, typename T>
inline R add(T a, T b)
{
    return a + b;
}


Documenting parts of a declaration ¶

In addition to annotating a top-level declaration, Sandcastle supports documenting parts of a declaration.


Class methods, variables, and callbacks ¶

Class methods and variables are annotated using //| in the same way as top-level declarations. Public members are always displayed. Private callbacks will always be displayed. All other private members will be displayed only if they are annotated with a Sandcastle comment.

template <auto Maximum, auto Initial>
class counter
{
public:
    //| Convenient type alias.
    using ctr_t = count_t<Maximum>;

private:
    //| This is displayed in generated documentation.
    ctr_t _first = Initial;

    ctr_t _second = 0; // This will not be displayed.

    (uint32 x) -> uint2 callback; // This will be displayed
                                  // even if it is not annotated.

public:
    //| Returns the current count.
    inline ctr_t count()
    {
        ctr_t result;
        atomic
        {
            result = _first - _second;
        }
        return result;
    }
}


struct, enum, and union fields ¶

struct fields are annotated in the following styles:

template <typename T>
struct optional
{
    //| Pre: valid flag
    bool is_valid /*< Post: valid flag*/;

    //| Pre: underlying value
    T value /*< Post: underlying value*/;
}

enum fields are annotated in the following styles:

enum RGBColor : uint2
{
    //| Red
    RED
    //< Red
,
    //| Green
    GREEN
    //< Green
,
    //| Blue
    BLUE
    //< Blue
}

union fields are annotated in the following styles:

union ExampleUnion
{
    //| Pre: a larger number
    uint8 larger /*< Post: a larger number*/;

    //| Pre: a smaller number
    uint4 smaller /*< Post: a smaller number*/;
}


Template parameters and function arguments ¶

Individual template parameters and functions arguments are annotated using the following styles:

template
    < //| The type of the elements in the input array.
      typename T
    , //| The length of the input array.
      auto N
    , //| The type of the elements in the result array.
      typename R
    >
inline R[N] map1
    ( //| A function that maps input values to result values.
      (T) -> R fn
    , //| Input array
      T[N] x
    )
{}

template
    < typename T //< The type of the elements in the input array.
    , auto N     //< The length of the input array.
    , typename R //< The type of the elements in the result array.
    >
inline R[N] map2
    ( (T) -> R fn //< A function that maps input values to result values.
    , T[N] x      //< Input array.
    )
{}


Documentation structure ¶

The documentation for a module consists of three parts, listed in the order they appear:

1. The module title and description.
2. The module index list which includes hyperlinks to all locally exposed declaration descriptions and re-exposed modules and their declarations. The local declaration links appear first and in the order that they are listed in the original source code exposition list.
3. A list of all locally exposed declarations and their descriptions in the order they appear in the original source code.

Re-exposed declarations will only be displayed in the index section of the generated document.


Module description ¶

Sandcastle supports documenting a module with a description.

/*|
Copyright: (c) Microsoft Corporation. All rights reserved.

A description of this module, possibly containing @some markup@.
*/
module some.name {}


Hyperlinking ¶

Sandcastle hyperlinks type identifiers to their respective definitions, either locally or an imported module. If a type identifier is used and imported from a module that is not specified on the command-line, but instead included with --import-dir , then a dead link will be created.


Markup ¶

Sandcastle uses Pandoc’s Markdown syntax to format code comments. See the Pandoc Markdown manual for more details.


Svgbob ¶

Sandcastle supports Svgbob diagrams bounded by the @@ symbol.

//|
// @@
// +---+      ,-----\->
// |   |----->|   .-|
// |___|-/  /->---|-|-O
// @@

The SVG diagram will be rendered in the generated documentation if user specifies --svgbob on the command line and svgbob_cli is installed and located on environment PATH.

For more information on how to create awesome diagrams see the Svgbob specification .


Anchors ¶

Include an anchor to link to a point in the documentation which doesn’t correspond to a particular entity. The syntax is [My anchor]{#label .anchor} , where “label” is the name of the anchor. Link to a custom anchor using the hyperlink syntax: [link title](#label) .

See bracketed spans


Collapsible Examples ¶

Use the following syntax, header 4 strong with either “Example” or “Examples” followed by one or more pairs of an optional paragraph and a code block, to render a collapsible example code block:

#### __Example__

    some code block

renders

some code block

Optionally include some paragraph text before each code block:

#### __Examples__

    code block 1

Case 2

    code block 2

renders

code block 1

Case 2

code block 2


References ¶

- Pandoc Markdown

- Markdown
